mixin highlight(target, search, highlightClass)
  - const searchRegex = new RegExp(`(${search})`, 'gi');
  - const tokens = target.replace(searchRegex, '<>$1<>').split('<>');
  for token in tokens.filter(Boolean)
    span(class={[highlightClass]: token.toLowerCase() === search.toLowerCase()})= token

.mp-tag-selector-container
  if loadState == 'loading_widget'
    .spinner
      mp-spinner
  else
    content
    .top-input-wrapper
      .input-wrapper
        if loadState == 'loading_tag'
          mp-spinner
        else if loadState == 'loaded_tag'
          svg-icon.tag-icon.loaded(attrs={icon: 'tag'})
        else if loadState == 'error'
          svg-icon.tag-icon.loaded-error(attrs={icon: 'tag'})
        else
          svg-icon.tag-icon(attrs={icon: 'tag'})

        if !$component.isAttributeEnabled('read-only')
          for tag in selectedTags
            .tag
              span= tag
              svg-icon.close-icon(
                attrs={icon: 'x'}
                on={click: () => $helpers.removeTag(tag)}
              )
        input.search-input(
          attrs={type: 'text'}
          on={
            input: $helpers.setInputText,
            keydown: $helpers.handleKeyActions,
          }
        )
        .border(class={'loaded-error': loadState === 'error'})
        .arrow-return-icon
          svg-icon(attrs={icon: 'arrow-return'})
    .list-options-wrapper
      for option, i in $helpers.getSearchMatches()
        .option(
          class={
            active: i === 0 && inputText !== '',
            bold: inputText === '',
          }
          on={click: () => $helpers.addTag(option)}
        )
          +highlight(option, inputText, 'bold')
    if $helpers.shouldShowFooter()
      .footer(on={click: () => $helpers.addTag(inputText)})
        .copy Create new label for
        .label-name= inputText
